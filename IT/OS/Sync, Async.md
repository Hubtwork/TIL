### Synchronous I/O & Asynchronous I/O

> Sync, Async 의 차이는 크게 `요청` 과 `응답` 이 처리되는 `시간` 에 의해 구분
>
> **Synchronous** - `호출된 함수` 의 리턴 시점이 결과를 반환하는 시점과 일치
>
> **Asynchronous** - `호출된 함수` 의 리턴 시점이 결과를 반환하는 시점과 불일치



#### Background

- **블로킹 , 논블로킹** 에 대해 정리하고 다시 한번 알아보면서 **동기 , 비동기** 의 개념도 확실히 잡아야 한다는 생각이 들었다
- 사실 실제로 설계적 측면의 작동 방식을 얘기할 때 **Block + Sync** 과 **Non-Block + Async** 의 조합에 익숙해져 이를 **Block == Sync** 로 혼동하는 사람이 의외로 많았기에 나 또한 재정립이 필요하다고 생각했다
- 이를 기점으로 사소하고 우리 사이에 정형화되어, 관습화되어 내려오는 개념들을 하나 하나 다시 확인하는 시간을 만들것 !



#### Synchronous I/O

- `요청` 에 대한 `응답` 이 올 떄까지 대기하는 방식
- `호출된 함수` 가 작업 수행 및 완료할 때까지 `호출한 함수` 또한 이를 신경쓰는 방식
- **Synchronous I/O** - CPU 가 I/O 작업 완료를 지속적으로 확인하거나 완료될때까지 *대기* 하는 방식
- **Synchronous I/O Flow**
  - `메인 스레드` 가 작업중 `서브 스레드` 에 `Task` 를 요청
  - `메인 스레드` 는 `서브 스레드` 가 `Task` 를 완료해 결과값을 Return 해줄 때 까지 대기
  - 즉 `서브 스레드` 가 `메인 스레드` 에게 Return 하는 값은 `Task` 요청에 대한 결과와 같음
- **특징**
  - `메인 스레드` 가 `서브 스레드` 의 결과를 받을 때까지 대기함으로 위임된 작업의 시간이 길어질 시 **작업의 효율성 저하**
  - `메인 스레드` 가 `응답` 을 받기까지 대기상태이므로 `작업 대상의 처리속도 및 결과` 에 대한 **의존도가 높아짐**
  - **Non-Blocking** 방식의 `대상` 과 작업 수행을 통해 단점을 보완
    - **Non-Blocking** 을 지원하는 `대상` 의 경우 호출에 대한 응답을 지속적으로 체크하는 방식 ( **Polling** ) 을 활용
    - **Sync** 의 경우 응답이 올 떄까지만 대기함으로 **Polling** 을 통해 *아직 완료되지 않았다* 는 응답만 바로 온다면 다른 작업을 수행할 수 있음
  - 애플리케이션의 설계가 보다 직관적이고 디자인적으로 가벼워짐



#### Asynchronous I/O

- `요청` 에 대한 `응답` 과는 상관없이 다음 작업을 수행하는 방식
- `호출된 함수` 혼자 작업 수행 및 완료를 신경쓰는 방식
- **Asnynchronous I/O** - CPU 작업과 I/O 작업을 **callback** 을 이용해 *병렬처리* 하는 방식
- **Asynchronous I/O Flow**
  - `메인 스레드` 가 작업중 `서브 스레드` 에 `Callback` 과 함께  `Task` 를 요청
  - `메인 스레드` 는 `서브 스레드` 가 작업을 완료할 때 까지 다른 작업을 진행
  - `서브 스레드` 는 작업이 완료되면 `Callback` 을 이용해 `메인 스레드` 에 통지
  - `메인 스레드` 는 `Callback` 을 통해 해당 작업의 결과를 출력
- **특징**
  - 동시에 여러 `요청` 을 진행해야할 경우 가장 긴 처리시간을 가진 `대상` 이 전체 처리시간과 동일하여 **속도가 빠름**
  - 애플리케이션의 설계가 복잡해지며 **Blocking** 방식의 `대상` 과 작업을 수행할 때 그 이점이 사라짐 
    - 대표적으로 `Mysql` 등의 DB 와 함께 Data 처리를 하는 `Node.js` 를 예로 들 수 있다
    - 대상이 부득이하게 **Non-Blocking** 을 지원하지 않아 부득이하게 **Blocking + Async** 조합을 사용할 경우 **Blocking + Sync** 조합과 수행이 동일하나 `Callback` 을 이용해 호출한다는 차이점밖에 없다
  - **Async** 의 경우 다수의 외부 API 와 통신할 시 어떤 작업이 먼저 끝날지 예측하기 힘들다
    - 각 응답에 대한 처리가 각자의 `Callback` 을 통해 이루어지므로 이를 병합 혹은 순차적으로 파이프라이닝 해야할 경우 복잡한 설계가 수반됨



#### Example

- `커피숍` 을 통해 `Block / Non-Block` , `Sync / Async` 를 이해하기 쉽게 설명해본다

- **Block + Sync**

  ~~~
  고객 - 아이스 아메리카노 한잔 주세요
  캐셔 - 네, 잠시만 기다려주세요
  ( 주방에서 주문을 받고 원액을 내리고 .... 커피 완성 )
  ( 고객은 커피를 받을 때까지 아무것도 안하고 서서 기다림 )
  캐셔 - 커피 나왔습니다
  고객 - ( 아 지루했다 )
  ~~~

- **Non-Block + Sync**

  ~~~
  고객 - 아이스 아메리카노 한잔 주세요
  캐셔 - 네, 다른 일 하시면서 기다려주세요
  ( 주방에서 주문을 받고 원액을 내리고 ... )
  고객 - 커피 다 됬나요 ?
  캐셔 - 아니요, 더 기다려주세요
  ( 주방에서 원액 내리는 중 ... )
  고객 - 커피 다 됬나요 ? 
  캐셔 - 아니요, 더 기다려주세요 손님.
  ( 주방에서 얼음 담는 중 ... )
  고객 - 커피 다 됬나요 ?
  캐셔 - 아니요, 아직 안됬습니다 손님 다른 거 하고 계세요...
  ~~~

- **Block + Async**

  ```
  고객 - 아이스 아메리카노 한잔 주세요
  캐셔 - 네, 잠시만 기다려주세요
  ( 주방에서 주문을 받고 원액을 내리고 .... 커피 완성 )
  ( 고객은 커피를 받을 때까지 언제 부를지 모르니 그 자리에서 웹툰 보며 기다림 )
  캐셔 - 커피 나왔습니다
  ```

- **Non-Block + Async**

  ~~~
  고객 - 아이스 아메리카노 한잔 주세요
  캐셔 - 네, 잠시만 기다려주세요
  ( 주방에서 주문을 받고 원액을 내리고 .... 커피 완성 )
  ( 고객은 가게 앞에서 잠시 업무 관련 통화 하는 중 )
  캐셔 - ( 가게 앞에 잠시 나와서 ) 저.. 1번 고객님 아이스 아메리카노 한잔 나왔습니다
  고객 - ( 통화 가리고 ) 아, 감사합니다. 고생하세요
  ~~~



### REFERENCE

- https://musma.github.io/2019/04/17/blocking-and-synchronous.html
- https://ssaemo.tistory.com/62
- https://ko.wikipedia.org/wiki/%EB%B9%84%EB%8F%99%EA%B8%B0_%EC%9E%85%EC%B6%9C%EB%A0%A5

